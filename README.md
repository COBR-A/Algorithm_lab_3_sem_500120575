# Algorithm Lab - 3rd 500120575 Semester 🚀


This repository contains implementations of various algorithmic problems solved as part of our lab exercises. Each lab explores core algorithmic strategies such as recursion, divide and conquer, greedy approaches, dynamic programming, and backtracking. Below is a brief overview of each experiment conducted:
file in the daa_lab
---

## 📂 LAB-1: Iterative and Recursive Binary Search Tree (BST) Insertion 🌳

**Topic:**  
Implement and compare the performance of **iterative** and **recursive** approaches for inserting elements into a Binary Search Tree.

- **Description:**  
  This experiment demonstrates two common methods for BST insertion. A detailed performance analysis is conducted to compare their runtime behavior, focusing on execution efficiency based on tree depth and element insertion order.

---

## 📂 LAB-2: Merge Sort and Quick Sort ⚔️

**Topic:**  
Apply **Merge Sort** and **Quick Sort**—both using the **divide and conquer** strategy—and compare their performance on the same set of elements.

- **Description:**  
  This experiment focuses on two of the most widely used sorting algorithms. We analyze and compare their time complexities by sorting various datasets and measuring their runtime under different scenarios.

---

## 📂 LAB-3: Matrix Multiplication - Strassen vs Traditional 🧮

**Topic:**  
Compare the **Strassen algorithm** for matrix multiplication with the traditional method.

- **Description:**  
  This lab delves into matrix multiplication by implementing both traditional and Strassen's algorithms. The goal is to highlight the performance improvements offered by Strassen’s method, particularly in reducing the number of recursive multiplications for larger matrices.

---

## 📂 LAB-4: Activity Selection Problem (Greedy Approach) 🏃‍♂️

**Topic:**  
Implement the **Activity Selection Problem** to understand how the greedy approach is applied.

- **Description:**  
  This experiment solves the Activity Selection Problem by choosing the maximum number of non-overlapping activities using a greedy approach. Performance analysis is done based on activity scheduling scenarios.

---

## 📂 LAB-5: Matrix Chain Multiplication (Dynamic Programming) 🧩

**Topic:**  
Implement **Matrix Chain Multiplication** and study how **parenthesis placement** affects performance using the dynamic programming approach.

- **Description:**  
  This lab focuses on solving the Matrix Chain Multiplication problem using dynamic programming. We analyze how different parenthesis arrangements influence the total cost of matrix multiplications and discuss the time complexity improvements with optimal parenthesis positioning.

---

## 📂 LAB-6: Single Source Shortest Path - Dijkstra vs Bellman-Ford 🛤️

**Topic:**  
Compare the performance of **Dijkstra's algorithm** and the **Bellman-Ford algorithm** for solving the single-source shortest path problem.

- **Description:**  
  The objective is to implement both algorithms and measure their runtime for graphs with varying edge weights. This lab also focuses on analyzing the performance in cases of negative weight edges (handled by Bellman-Ford) versus non-negative edges (optimized by Dijkstra).

---

## 📂 LAB-7: 0/1 Knapsack Problem (Greedy vs Dynamic Programming) 💼

**Topic:**  
Analyze the **greedy** and **dynamic programming** approaches to solving the **0/1 Knapsack problem** using the same dataset.

- **Description:**  
  This lab demonstrates two distinct approaches to the knapsack problem. We compare the results produced by the greedy heuristic versus the more optimal dynamic programming approach, focusing on accuracy and performance trade-offs.

---

## 📂 LAB-8: Sum of Subsets Problem ✨

**Topic:**  
Implement the **Sum of Subsets** problem to find all subsets that sum up to a given target value.

- **Description:**  
  The Sum of Subsets problem is solved using backtracking to explore all possible subsets and return those that meet the sum condition. We discuss the efficiency of this method and its potential applications.

---

## 📂 LAB-9: 0/1 Knapsack Problem - Backtracking vs Branch and Bound 🔗

**Topic:**  
Compare the **Backtracking** and **Branch & Bound** approaches for solving the **0/1 Knapsack problem** and contrast their performance with the **dynamic programming** approach.

- **Description:**  
  This experiment involves solving the 0/1 Knapsack problem using backtracking and branch & bound techniques, and then comparing their performance with dynamic programming. A focus is placed on computational complexity and execution time for different input sizes.

---

## 📂 LAB-10: String Matching Algorithms - Rabin-Karp, Knuth-Morris-Pratt, Naive 🧵

**Topic:**  
Compare the **Rabin-Karp**, **Knuth-Morris-Pratt (KMP)**, and **Naive string matching** algorithms.

- **Description:**  
  In this lab, we implement three string-matching algorithms to search for a pattern within a string. The goal is to compare the time efficiency of each method based on the length of the string and pattern.

---

### 💡 Repository Highlights:

- **Language Used:** C/Python
- **Concepts Covered:** Recursion, Dynamic Programming, Divide & Conquer, Greedy Algorithms, Backtracking, and Branch & Bound.
- **Performance Metrics:** Each experiment includes a detailed runtime analysis to compare the efficiency of the implemented algorithms.

---

This repository serves as a comprehensive guide for understanding and implementing foundational algorithmic concepts, aimed at developing practical problem-solving skills in computational thinking.
